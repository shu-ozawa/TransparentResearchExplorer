# Backend Documentation

This document provides a comprehensive overview of the backend architecture, API endpoints, database setup, external service integrations, and key dependencies for the Transparent Research Explorer application.

## Overall Architecture

The backend is a Python application built using the FastAPI framework. It follows a modular design to separate concerns and enhance maintainability. The code is primarily organized into the following directories:

-   **`backend/app/`**: This directory contains the main FastAPI application setup (`main.py`) and clients for interacting with external services, such as the Google Gemini API (`clients/gemini_client.py`).
-   **`backend/api/`**: This directory is responsible for handling interactions with external APIs (like the arXiv academic paper service via `arxiv_client.py`) and defining the structure of the application's own API endpoints (`endpoints/`).
-   **`backend/core/`**: This directory houses core functionalities essential for the application's operation, most notably database setup, configuration, and session management (`database.py`).
-   **`backend/models/`**: Defines the SQLAlchemy Object-Relational Mapper (ORM) models (`paper.py`), which represent the structure of database tables.
-   **`backend/schemas/`**: Contains Pydantic models (`arxiv_schema.py` and others defined inline within endpoint files) that are used for data validation, serialization, and automatic API documentation for request and response bodies.

### `backend/app/main.py` - FastAPI Application

The `app/main.py` script is the entry point and core of the backend application. Its responsibilities include:

-   **FastAPI App Initialization**: It creates an instance of the `FastAPI` application, setting global configurations like the application title and description.
-   **Database Setup**: On startup, it calls `create_db_and_tables()` (from `backend.core.database`) to ensure that all necessary database tables (defined in `backend/models/`) are created in the SQLite database.
-   **Router Inclusion**: It includes API routers from the `backend.api.endpoints` modules. Each router groups related endpoints under a common prefix (e.g., `/api/arxiv`, `/api/queries`, `/api/papers`), making the API structure organized and versionable.
-   **Root Endpoint**: Defines a basic GET endpoint at `/` for health checks or simple welcome messages.

## API Endpoints

The backend exposes several RESTful API endpoints, primarily defined within the `backend/api/endpoints/` directory. These endpoints facilitate interaction with the frontend and manage data operations.

### 1. ArXiv Endpoints (`/api/arxiv`)

Managed by `backend/api/endpoints/arxiv.py`. These endpoints allow searching the arXiv repository.

-   **`GET /search`** and **`POST /search`**
    -   **Purpose**: Search for papers on arXiv based on a specified keyword. The GET version accepts parameters as URL query strings, while the POST version expects a JSON request body.
    -   **Inputs**:
        -   `keyword` (str): The search term or keyword.
        -   `max_results` (int, optional, default: 10): The maximum number of papers to return.
    -   **Request Body (for POST)**: `ArxivSearchRequest` schema (`{ "keyword": "...", "max_results": ... }`)
    -   **Outputs**: `ArxivSearchResponse` schema (`{ "papers": [...], "total_results": ... }`)
        -   `papers`: A list of `ArxivPaper` objects, each containing details like `entry_id`, `title`, `authors`, `summary`, `published` date, `updated` date, `pdf_url`, and `categories`.
        -   `total_results`: The number of papers returned in the current response.

### 2. Papers Endpoints (`/api/papers`)

Managed by `backend/api/endpoints/papers.py`. This group currently focuses on processing and scoring papers.

-   **`POST /score`**
    -   **Purpose**: Generate a relevance score (0-1) and a textual explanation of how relevant a given research paper is to a specific query. This is achieved by leveraging the Gemini language model.
    -   **Inputs**: `ScoreRequest` schema
        -   `paper` (object): Contains paper information:
            -   `title` (str)
            -   `authors` (list of str)
            -   `abstract` (str)
        -   `query` (str): The user's query to compare against the paper.
    -   **Outputs**: `RelevanceScoreResponse` schema
        -   `score` (float): A numerical score between 0.0 (not relevant) and 1.0 (highly relevant).
        -   `explanation` (str): A brief text generated by Gemini explaining the reasoning behind the assigned score.
    -   **Gemini Interaction**: The endpoint constructs a detailed prompt combining the paper's abstract, title, and authors with the user's query. This prompt is sent to the Gemini API, and the response is parsed to extract the score and explanation.

### 3. Queries Endpoints (`/api/queries`)

Managed by `backend/api/endpoints/queries.py`. These endpoints handle query generation and searching/caching of papers.

-   **`POST /generate`**
    -   **Purpose**: Generate a list of related search queries based on an initial set of keywords or a research theme provided by the user. This uses the Gemini language model to brainstorm and suggest alternative or more specific queries.
    -   **Inputs**: `QueryGenerationRequest` schema
        -   `initial_keywords` (str): The user's starting keywords or research topic.
    -   **Outputs**: `QueryGenerationResponse` schema
        -   `original_query` (str): The initial keywords provided by the user.
        -   `related_queries` (list of objects): A list where each object contains:
            -   `query` (str): The suggested related query.
            -   `description` (str): A brief description of what the related query focuses on.
    -   **Gemini Interaction**: A prompt is formulated using the `initial_keywords` to ask Gemini to generate 5-7 related queries along with their descriptions. The text response from Gemini is then parsed to structure it into the output format.

-   **`POST /search`**
    -   **Purpose**: Search for papers on arXiv using a list of provided queries, integrate the results, cache them in the local database to minimize redundant external API calls, and return essential information for the found papers.
    -   **Inputs**: A list of `SearchQuery` objects. Each `SearchQuery` object contains:
        -   `query` (str): The specific search query string.
        -   `max_results` (int, optional, default: 10): Max results for this specific query.
    -   **Outputs**: A list of `PaperSearchResponse` objects. Each object contains:
        -   `title` (str)
        -   `authors` (list of str)
        -   `summary` (str)
        -   `published_date` (datetime)
        -   `url` (str, typically the PDF URL)
    -   **Cache Interaction**:
        1.  For each query in the input list, the system first uses the `ArxivAPIClient` to get a list of paper `entry_id`s from arXiv.
        2.  It then checks the local `papers_cache` database table (via the `Paper` model) to see if papers with these `entry_id`s already exist.
        3.  If a paper is found in the cache, its data is used directly.
        4.  If a paper is not found in the cache, the data fetched from arXiv (via `ArxivAPIClient`) is saved to the `papers_cache` table for future requests.
        5.  The combined results (cached and newly fetched) are then formatted and returned.

## Database (`backend/core/database.py`, `backend/models/paper.py`)

The backend utilizes a local SQLite database for caching and data persistence.

-   **Database File**: `tre_cache.db` (located in the `backend/` directory).
-   **SQLAlchemy**: The application uses SQLAlchemy as its Object-Relational Mapper (ORM).
    -   `backend/core/database.py` configures the database engine (`create_engine`) and session management (`SessionLocal`, `get_db` dependency for FastAPI). It also provides `Base` for declarative model definitions and a function `create_db_and_tables()` to initialize the database schema.
-   **`Paper` Model (`backend/models/paper.py`)**:
    -   This SQLAlchemy model defines the structure of the `papers_cache` table.
    -   **Fields include**:
        -   `id` (Integer, Primary Key)
        -   `arxiv_id` (String, Unique, Indexed): The unique identifier from arXiv.
        -   `title` (String)
        -   `authors` (JSON): Stored as a JSON array of author names.
        -   `abstract` (Text)
        -   `published_date` (DateTime)
        -   `url` (String): Typically the PDF link.
        -   `created_at`, `updated_at` (DateTime): Timestamps for record management.
    -   **Role of `papers_cache` Table**: This table acts as a cache for paper metadata fetched from arXiv. By storing results locally, the application can significantly reduce the number of calls to the external arXiv API, leading to faster response times for repeated queries and less load on the arXiv servers. The `/api/queries/search` endpoint is the primary interface for this caching mechanism.

## External Service Interaction

The backend integrates with two main external services: arXiv and Google Gemini.

### 1. ArXiv (`backend/api/arxiv_client.py`)

-   **Purpose**: To search and retrieve academic paper metadata from the arXiv.org e-print archive.
-   **Interaction**:
    -   The `ArxivAPIClient` class encapsulates the logic for interacting with arXiv.
    -   It uses the official `arxiv` Python library.
    -   The `search_papers` method takes a keyword and maximum number of results, queries the arXiv API, and transforms the results into a list of `ArxivPaper` Pydantic schema objects.
    -   **Retry Logic**: The client incorporates retry functionality using the `tenacity` library. If an API call to arXiv fails (e.g., due to `ArxivHTTPError` or `ArxivUnexpectedEmptyPageError`), it will automatically retry the request a few times with exponential backoff, enhancing the robustness of the integration.

### 2. Gemini (`backend/app/clients/gemini_client.py`)

-   **Purpose**: To leverage Google's Gemini large language model for advanced text generation and understanding tasks.
-   **Interaction**:
    -   The `GeminiClient` class manages communication with the Gemini API.
    -   It requires the `GEMINI_API_KEY` to be set as an environment variable for authentication.
    -   The primary method, `generate_text(prompt: str)`, sends a given prompt to the `gemini-pro` model and returns the generated text response.
    -   **Usage in Application**:
        -   **Relevance Scoring (`/api/papers/score`)**: Gemini is used to assess how relevant a research paper is to a user's query by generating a numerical score and a textual justification.
        -   **Related Query Generation (`/api/queries/generate`)**: Gemini is used to brainstorm and suggest related or alternative search queries based on a user's initial keywords or research theme.
    -   The client includes basic error handling for API calls and response parsing.

## Data Schemas (Pydantic Models)

-   **Location**: Defined in `backend/schemas/arxiv_schema.py` (for arXiv-specific structures) and also inline within the respective endpoint files in `backend/api/endpoints/` for other request/response bodies.
-   **Purpose**: Pydantic models are crucial for several reasons:
    -   **Data Validation**: They automatically validate incoming request data. If the data doesn't conform to the defined schema (e.g., wrong data type, missing fields), FastAPI returns a clear error response.
    -   **Data Serialization**: They are used to structure and serialize outgoing response data, ensuring consistency.
    -   **API Documentation**: FastAPI uses these Pydantic models to automatically generate interactive API documentation (e.g., via Swagger UI or ReDoc), showing expected request and response formats. This makes the API self-documenting and easier to understand and use.

## Key Dependencies (`backend/requirements.txt`)

The backend relies on several key Python libraries:

-   **`fastapi`**: A modern, fast (high-performance) web framework for building APIs with Python 3.7+ based on standard Python type hints.
-   **`uvicorn[standard]`**: An ASGI (Asynchronous Server Gateway Interface) server, used to run the FastAPI application. The `[standard]` option includes useful extras like websockets and http/2 support.
-   **`google-generativeai`**: The official Python client library for Google's Generative AI APIs, including Gemini.
-   **`sqlalchemy`**: The Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL. Used for database interaction.
-   **`aiosqlite`**: An asynchronous driver for SQLite, necessary for using SQLAlchemy with SQLite in an async FastAPI application.
-   **`arxiv`**: A Python wrapper for the arXiv API, used to fetch paper data.
-   **`httpx`**: A fully featured HTTP client for Python 3, used by `TestClient` in FastAPI for testing API endpoints.
-   **`tenacity`**: A general-purpose retrying library, used in the `ArxivAPIClient` to handle transient errors when calling the arXiv API.
-   **`pytest`, `pytest-asyncio`, `pytest-mock`**: Libraries used for testing the application (though not directly part of the runtime, they are crucial for development).

This documentation should provide a clear understanding of the backend system's components and their interactions.
---
